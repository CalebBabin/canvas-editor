/**
 * @typedef {Object} EditorConfig
 * @property {boolean} editable - can the user interact with the canvas?
 */

/**
 * @typedef {Object} WorkerRecord
 * @property {Worker} worker
 * @property {string} type
 */

/**
 * @typedef {CanvasItemWorkerData}
 * @property {number} id - a local integer ID generated by the editor
 * @property {string} type
 * @property {Object} data
 * @property {HTMLCanvasElement} canvas
 */
/**
 * @typedef {CanvasItemLocalData}
 * @property {Object} container
 */

/**
 * @typedef {Array} CanvasItem
 * @property {CanvasItemLocalData} container
 * @property {CanvasItemWorkerData} data
 */



let running_id = 0;
function get_id() {
	running_id += 1;
	return running_id;
}

const defaultConfig = {
	editable: true,
}

import { css } from '@emotion/css';
const container_styles = css`
	width: 100%;
	height: 100%;
	position: relative;
	overflow: hidden;
`;

const contents_styles = css`
	width: 0;
	height: 0;
	position: absolute;
	top: 50%;
	left: 50%;
	overflow: visible;
`;

const item_styles = css`
	position: absolute;
	overflow: visible;

	box-shadow: 0 0 10px 0px rgba(255, 0, 0, 0.5);
	border-radius: 10px;
	border: 1px solid #ffffff22;

	padding: var(--canvas-item-padding);

	& > canvas {
		position: absolute;
		top: var(--canvas-item-padding);
		left: var(--canvas-item-padding);
		width: calc(100% - var(--canvas-item-padding) * 2);
		height: calc(100% - var(--canvas-item-padding) * 2);
	}
`;

export default class Editor {

	/**
	 * @type {EditorConfig}
	 */
	config = { ...defaultConfig };

	/** @private the x coordinate of the canvas viewport */
	#x = 0;
	/** @private the y coordinate of the canvas viewport */
	#y = 0;
	/** @private the scale of the canvas viewport */
	#scale = 1;

	/**
	 * Sets the x coordinate of the canvas viewport
	 * @param {number} value - The x coordinate to set
	 */
	set x(value) {
		this.#x = value;
		this.#updateContentTransform();
	}
	/**
	 * The current x coordinate of the canvas viewport
	 * @returns {number} The current x coordinate
	 */
	get x() {
		return this.#x;
	}
	/**
	 * Sets the y coordinate of the canvas viewport
	 * @param {number} value - The y coordinate to set
	 */
	set y(value) {
		this.#y = value;
		this.#updateContentTransform();
	}
	/**
	 * The current y coordinate of the canvas viewport
	 * @returns {number} The current y coordinate
	 */
	get y() {
		return this.#y;
	}

	/**
	 * Sets the scale of the canvas viewport
	 * @param {number} value - The scale to set
	 */
	set scale(value) {
		this.#scale = value;
		this.#updateContentTransform();
	}
	/**
	 * The current scale of the canvas viewport
	 * @returns {number} The current scale
	 */
	get scale() {
		return this.#scale;
	}

	/** Current mouse x position relative to the canvas viewport */
	mouseX = 0;
	/** Current mouse y position relative to the canvas viewport */
	mouseY = 0;

	/**
	 * The container for the editor
	 */
	container = document.createElement('div');

	/**
	 * The container for the contents of the editor
	 */
	contents = document.createElement('div');

	/**
	 * 
	 * @param {EditorConfig} config 
	 */
	constructor(config) {
		this.config = { ...defaultConfig, config };

		this.container.style.setProperty('--canvas-item-padding', '0.5em');
		this.container.classList.add(container_styles);
		this.contents.classList.add(contents_styles);
		this.container.appendChild(this.contents);

		this.#addListeners();
	}

	/**
	 * @type {CanvasItem[]}
	 */
	#items = [];

	/**
	 * 
	 * @param {string} type 
	 * @param {Object} data 
	 * @returns {CanvasItem}
	 */
	addItem(type, data) {
		const id = get_id();
		const canvas = document.createElement('canvas');

		if (!data.width) data.width = 100;
		if (!data.height) data.height = 100;
		canvas.width = data.width;
		canvas.height = data.height;
		canvas.dataset.id = id;

		const itemContainer = document.createElement('div');
		itemContainer.classList.add(item_styles);
		itemContainer.appendChild(canvas);
		this.contents.appendChild(itemContainer);

		itemContainer.appendChild(canvas);

		const offscreenCanvas = canvas.transferControlToOffscreen();

		/**
		 * @type {CanvasItem}
		 */
		const item = [
			{
				container: itemContainer
			},
			{
				id,
				canvas: offscreenCanvas,
				type,
				data,
			}
		]
		this.#items.push(item);
		this.#updateItem(item);

		const record = this.getWorkerRecord(type);
		if (record) {
			console.log('worker record found', record.worker, data);
			record.worker.postMessage(['update', item], [offscreenCanvas]);
		} else {
			console.log('no worker record', type, data);
		}
		return item;
	}

	/**
	 * 
	 * @param {WorkerRecord} worker 
	 */
	#sendItemsToWorker(record) {
		this.#items.forEach(item => {
			if (item[1].type === record.type) {
				console.log(record, item);
				record.worker.postMessage(['update', item[1]], [item[1].canvas]);
			}
		});
	}

	/**
	 * @type {WorkerRecord[]}
	 */
	#workers = [];

	/**
	 * Adds a worker to the canvas editor to handle a new object type
	 * @param {Worker} worker
	 */
	addWorker(worker) {
		const record = {
			id: get_id(),
			worker,
		}

		worker.onmessage = (event) => {
			console.log('worker message', event.data);
			const { event_name, data } = event.data;
			switch (event_name) {
				case 'type': {
					const oldWorker = this.getWorkerRecord(record.type);
					if (oldWorker && oldWorker !== record) {
						console.log('terminating old worker', oldWorker);
						oldWorker.worker.terminate();
					}

					record.type = data;
					this.#sendItemsToWorker(record);
				} break;
				case 'update': {
					const { id, data } = event.data;
					const item = this.#items.find(item => item[1].id === id);
					if (item) item[1].data = data;
					this.#updateItem(item);
				} break;
			};
		}
		worker.postMessage(['type']);

		this.#workers.push(record);
	}

	#updateItem(item) {
		const data = item[1].data;
		const container = item[0].container;
		container.style.width = data.width + 'px';
		container.style.height = data.height + 'px';

		let transform = 'translate(' + (data.x - data.width / 2) + 'px, ' + (data.y - data.height / 2) + 'px)';
		if (data.rotation) transform += ' rotate(' + data.rotation + 'deg)';
		container.style.transform = transform;
	}

	/**
	 * Gets a worker from the canvas editor by type
	 * @param {string} type
	 * @returns {WorkerRecord}
	 */
	getWorkerRecord(type) {
		return this.#workers.find(item => item.type === type);
	}

	#updateContentTransform() {
		this.contents.style.transform = 'translate(' + -this.#x + 'px, ' + -this.#y + 'px) scale(' + this.#scale + ')';
	}

	/**
	 * Calculates and updates the mouse position relative to the canvas viewport
	 * @param {number} x - The client X coordinate
	 * @param {number} y - The client Y coordinate
	 */
	calculateMousePosition(x, y) {
		const box = this.container.getBoundingClientRect();
		this.mouseX = (x - this.#x - (box.width / 2 + box.left)) / this.#scale;
		this.mouseY = (y - this.#y - (box.height / 2 + box.top)) / this.#scale;
	}

	/**
	 * Handles mouse move events
	 * @private
	 * @param {MouseEvent} event - The mouse move event
	 */
	#mouseMove = (event) => {
		this.calculateMousePosition(event.clientX, event.clientY);
	}

	/**
	 * Handle scroll events, such as panning and zooming
	 * @private
	 * @param {WheelEvent} event - The wheel event
	 */
	#scroll = (event) => {
		this.calculateMousePosition(event.clientX, event.clientY);
		if (event.ctrlKey) {
			const oldScale = this.scale;
			this.scale -= (event.deltaY / 500) * this.scale;
			this.x -= this.mouseX * (oldScale - this.scale);
			this.y -= this.mouseY * (oldScale - this.scale);
		} else {
			let moveScale = (1 / this.scale);
			if (moveScale < 0.1) moveScale = 0.1;
			if (moveScale > 1) moveScale = (moveScale - 1) * 0.01 + 1;

			this.x += event.deltaX * moveScale;
			this.y += event.deltaY * moveScale;
		}

		event.preventDefault();
	}

	/**
	 * Adds event listeners to the container
	 * @private
	 */
	#addListeners() {
		this.container.addEventListener('mousemove', this.#mouseMove);
		this.container.addEventListener('wheel', this.#scroll);
	}

	/**
	 * Removes event listeners from the container
	 * @private
	 */
	#removeListeners() {
		this.container.removeEventListener('mousemove', this.#mouseMove);
		this.container.removeEventListener('wheel', this.#scroll);
	}

	/**
	 * Destroys the canvas editor
	 */
	destroy() {
		this.destroying = true;
		this.#removeListeners();
		this.#workers.forEach(worker => worker.terminate());
	}
}
